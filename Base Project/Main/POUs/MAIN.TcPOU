<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="MAIN" Id="{0790caa7-8a3f-4f91-b0f8-9ebb3db3858d}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR

	// ========= System Control / FSM Variables =========
	
	MainCommands 		: MainCommands_typ; 	// command struct for cycling thru the state machine
	MainState    		: MainState_enum;   	// enumeration for the Main state machine

	// ========= Linked NC Variables & References =========
	
	Mover    			: ARRAY[0..GVL.NUM_MOVERS - 1] OF Mover; 	// instantiation of Mover objects. Matches the number of movers on the system
    GroupRef 			: AXES_GROUP_REF;                       	 // linked to the Collision Avoidance group and passed cyclically to every Mover object

	// ========= Objectives & Parameters =========

    MoverList    		: MoverList;
    ParameterSet 		: MotionParameters_typ;

    Station         	: ARRAY[0..GVL.NUM_STATIONS - 1] OF Station;
    PositionTrigger 	: ARRAY[0..2] OF PositionTrigger;
    SpeedTrigger    	: ARRAY[0..1] OF SpeedTrigger;
    Zone            	: ARRAY[0..3] OF Zone;
	
    // ========= Example Application Variables =========

    nextStation 		: USINT := 4;
                    	
    lowVelocity    		: LREAL := 200;  	// mm/s
    mediumVelocity 		: LREAL := 800;  	// mm/s
    highVelocity   		: LREAL := 1200; 	// mm/s

    // ========= Helper, State, & Index Variables =========
	
    i                	: UINT; 	// index variable; gets reused in various FOR loops
    n                	: UINT; 	// secondary index variable, for enabling movers
    allMoversEnabled 	: BOOL; 	// helper flag for verifying enable status of all movers
	allMoverTracksEnabled : BOOL;	// helper flag for verifying track active status of all movers
	allMoversDisabled	: BOOL;		// helper flag for verifying disable status of all movers
	allMoversHalted		: BOOL;		// helper flag for verifying halt status of all movers

    StationTimer 		: ARRAY[0..GVL.NUM_STATIONS] OF TON; // timer blocks, for station dwells	
	
	// ========= XTS Utility Diagnostics =========
	
	VisuDiag						: FB_VisuXtsDiag;
	fbXtsEnvironment				: FB_TcIoXtsEnvironment;
	fbXtsEnvironmentVisu			: FB_XtsEnvironmentVisu;
	stXtsEnvironmentConfiguration	: ST_XtsEnvironmentConfiguration;
	nEnvironmentState				: INT;
	
	// ======== Track management ========
	Track		: ARRAY [0..GVL.NUM_TRACKS] OF Track;
	
	
	// ======== Queue Logic Variables ========
	temp_payload : payload_TYP;
	SB_dispensers : ARRAY [1..3] OF StarburstDispenser;
	//make an array
	
	
	current_order : Order_TYP;
	hmi_order : Order_TYP;
	red : INT;
	orange : INT;
	pink : INT;
	bconfirm_order: BOOL := FALSE;
	bpicked_up: BOOL;
	
	order_num_signal: INT := 0;
	temp: Payload_TYP;
	number: INT;
	
	Axis1 : FB_BasicAxis;
	Axis2 : FB_BasicAxis;
	Axis3 : FB_BasicAxis;
	
	state1: INT;
	state2: INT;
	state3: INT;
	
	spin: INT;
	temporary: Payload_TYP;
	
	update: BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[	



(* ======================================================================================

--- XTS Starter Project ---

This MAIN (PRG) is intended to serve as an example, which can be modified to suit your specific application.

No programming changes should be necessary inside the provided XTS objects / function block definitions.
They are intended to be simply instantiated and controlled via the provided methods and properties.
However the objects are provided as open-source for modification and extension as needed.

Documentation for these objects can be found online at:
https://beckhoff-usa-community.github.io/XTS_Base/

Bug reports, new feature requests, and general feedback is always welcome on our Github page.
For any other questions, please reach out to your local Application Engineer.

- Beckhoff USA Advanced Applications Group

====================================================================================== *)





CASE MainState OF
    MS_DISABLED: // --------------------------------------------------------- IDLE STATE
		(*Wait here until an operator issues a MainCommand to Enable the system. 
		Disallow Start and Stop commands until the system has been Enabled*)
	
        MainCommands.Start		:= FALSE;
		MainCommands.Stop		:= FALSE;
		
        IF MainCommands.Enable THEN
            MainCommands.Disable := FALSE;
            MainState            := MS_INITIALIZING_MOVERS;
        END_IF

    MS_INITIALIZING_MOVERS: // --------------------------------------------- SET MOVER MOTION PARAMETERS
		(*Initialize Mover motion parameters via a Parameter Set. Once complete, step
		forward to begin Enabling movers on the system*)
		
		ParameterSet.Jerk         := 1E5; // mm/s3
		ParameterSet.Acceleration := 1E4; // mm/s2
		ParameterSet.Deceleration := 1E4; // mm/s2
		ParameterSet.Velocity     := 1E3; // mm/s
		ParameterSet.Direction    := mcDirectionPositive;

        FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
            Mover[i].MotionParameters := ParameterSet;
        END_FOR
		
		IF MainCommands.Disable THEN
			MainCommands.Enable		:= FALSE;
			MainState				:= MS_DISABLED;
		ELSIF MainCommands.Stop THEN
			MainCommands.Stop		:= FALSE;
			MainCommands.Disable	:= TRUE;
			MainCommands.Start		:= FALSE;
			MainState				:= MS_DISABLED;
		ELSIF MainCommands.Enable THEN
        	MainState 				:= MS_ONESHOT_ENABLE;
		END_IF

	MS_ONESHOT_ENABLE:	// -------------------------------------------------- SINGLE-CYCLE ISSUE ENABLE COMMANDS
		(*Begin Enabling movers by calling Mover.Enable(). Methods in this project
		are intended to be called once, although they will function correctly if called repeatedly*)

		FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
			Mover[i].Enable();
		END_FOR

		MainState		:= MS_ENABLING_MOVERS;
	
    MS_ENABLING_MOVERS: // -------------------------------------------------- RESETTING AND ENABLING AXES
		(*Wait here until all movers have Enabled. This means that the Axis has
		fully energized, and also that all Collision Avoidance grouping and Mover 1 detection
		has finished. If the state machine gets stuck in this state, check the Error output
		of an individual Mover to see what the issue is. A common cause is forgetting to link
		Mover NC Axes to the AXIS_REF inside the PLC*)

        allMoversEnabled := TRUE; // default ...

        FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
            IF Mover[i].Ready = FALSE THEN
                allMoversEnabled 		:= FALSE;
            END_IF
        END_FOR
		
		Axis1.Enable();
		Axis2.Enable();
		Axis3.Enable();

        IF allMoversEnabled THEN
			IF MainCommands.Disable THEN
				MainCommands.Enable		:=FALSE;
            	MainState				:= MS_ONESHOT_DISABLE;
			ELSIF MainCommands.Stop	 THEN
				MainCommands.Start		:=FALSE;
				MainState				:= MS_ONESHOT_STOP;
			ELSIF MainCommands.Enable THEN
	        	MainState 				:= MS_INITIALIZING_OBJECTIVES;
			END_IF
        END_IF

    MS_INITIALIZING_OBJECTIVES: // --------------------------------------------- WRITING OBJECTIVE PARAMETERS
		(*Initialize Station positions, Position Trigger positions, Zones etc. *)

        // Initialize station positions
        Station[0].Position := 1250;
        Station[1].Position := 25;
        Station[2].Position := 127;
        Station[3].Position := 228;
        Station[4].Position := 875;

       
        Zone[0].StartPosition := 0;
        Zone[0].EndPosition   := 1500;

		
		// give all tracks their ID number
		FOR i := 0 TO GVL.NUM_TRACKS DO
			Track[i].Id := UINT_TO_INT(i);
		END_FOR
		
		// Track 0 is a special case absolute reference, no-modulus track instance and is not normally used
		Track[0].OTCID := 0;				// special "absolute reference" case
		Track[1].OTCID:= 16#01010060;		// value copied from XtsProcessingUnit1 > Track x > Object > Object Id field

		MainState := MS_ACTIVATE_TRACKS;
		
	MS_ACTIVATE_TRACKS:
		// activate all movers on track[1]
		FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
            Mover[i].ActivateTrack(Track[1]);
        END_FOR
		
		MainState := MS_WAIT_FOR_TRACKS;
	
	MS_WAIT_FOR_TRACKS:
		// wait for all movers to activate their tracks
		
		allMoverTracksEnabled := TRUE;
		FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
			IF (NOT Mover[i].IsTrackReady) THEN
            	allMoverTracksEnabled := FALSE;
			END_IF;
        END_FOR
		IF (allMoverTracksEnabled) THEN
			MainState := MS_ENABLED;	
		END_IF

    MS_ENABLED: // ------------------------------------------------------------- MOVERS ENABLED, STOPPED
		(*In this state, Movers should be energized and holding their position. They should wait
		until a Start command is issued. This is also a good state to include basic Recovery steps.
		Our example shows a simple use-case involving Zones for localized recovery*)

		MainCommands.Stop	:= FALSE;
	
        IF MainCommands.Start THEN

            // ===== RECOVERY LOGIC =====

            (*
			Recovery is typically very application-specific. Each implementation will need to determine
			what to do with work-in-progres, rejects, movers with unknown product status, etc.s
			*)

            // Register all movers with all Zones, for recovery
            FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
                Zone[0].RegisterMover( Mover[i] );
            END_FOR
			
            Zone[0].CurrentMoverList.SetAllVelocity(200).MoveAllToStation(Station[0]);

            // ===== END =====

            MainState			:= MS_RUN;

        ELSIF MainCommands.Disable THEN
            MainCommands.Enable := FALSE;
            MainState           := MS_ONESHOT_STOP;
        END_IF

    MS_RUN: // --------------------------------------------------------------- OPERATING
		(*Mover routing logic should be written here to define the system's operating behavior.
		Station implementations, Position Trigger logic, etc. In general, you can remove the example code
		here down to the short line break that looks like this: // ============= *)
	
	
		// Recieves order from user and populates queue
		IF bconfirm_order THEN
			hmi_order.order_num := GVL.order_number;
			hmi_order.red := red;
			hmi_order.orange := orange;
			hmi_order.pink := pink;
			
			
			//enqueues order
			Orders.ENQUEUE(hmi_order);
			// sets temporary variable holding the order information for the mover
			current_order := Orders.order;
			bconfirm_order := FALSE;
			//number := hmi_order.order_num;
			GVL.order_number := GVL.order_number + 1;
		END_IF
		
		
	
		
        // Station 0 Logic for start station
        IF Station[0].MoverInPosition THEN
			
			//Check if there is an order available
			IF Orders.HasOrder THEN
				
				
				//delete order off of the queue
				Orders.DEQUEUE();
	
				
			
				//set mover payload with order info
				temp_payload := Station[0].CurrentMover.Payload;
				temp_payload.Red := current_order.red;
				temp_payload.Orange := current_order.orange;
				temp_payload.Pink := current_order.pink;
				temp_payload.Order_Num := current_order.order_num;
				Station[0].CurrentMover.Payload := temp_payload;
				
				//Move to first station
				Station[0].CurrentMover.SetVelocity(500);
                Station[0].CurrentMover.MoveToStation(Station[1]);
				
				
			END_IF
       END_IF
	  
		
        // Station 1 Logig for Red starbursts	
		CASE state1 OF 
			0 :
			IF Station[1].MoverInPosition THEN 
				temporary := Station[1].CurrentMover.Payload;
				Axis3.Velocity := 7000;
				//Axis3.Deceleration := 8000;
				spin := temporary.Red * 360;
				IF(Axis3.MoveRelative(spin, TRUE))THEN
				state1 := 1;
				END_IF
			END_IF
			1 :
				IF NOT(Axis3.Busy) THEN
				Station[1].CurrentMover.SetVelocity(500);
                Station[1].CurrentMover.MoveToStation(Station[2]);
				state1 :=0 ;
				END_IF
			
		END_CASE
        //IF Station[1].MoverInPosition THEN
			
			// dispenses red starbursts
		//	SB_dispensers[1](mover := Station[1].currentMover, station_num := 1, dispense := TRUE, Axis := Axis3);
			
			//when done dispensing mover goes to next station
		//	IF SB_dispensers[1].completed THEN;
		//		SB_dispensers[1](mover := Station[1].currentMover, station_num := 1, dispense := FALSE);
         //       Station[1].CurrentMover.SetVelocity(500);
         //       Station[1].CurrentMover.MoveToStation(Station[2]);
         //   END_IF
			
     //   END_IF
		
		//Station 2 logic for Orange starbursts
		CASE state2 OF 
			0 :
			IF Station[2].MoverInPosition THEN 
				temporary := Station[2].CurrentMover.Payload;
				Axis2.Velocity := 7000;
				//Axis2.Deceleration := 8000;
				spin := temporary.Orange * 360;
				IF(Axis2.MoveRelative(spin, TRUE))THEN
				state2 := 1;
				END_IF
			END_IF
			1 :
				IF NOT(Axis2.Busy) THEN
				Station[2].CurrentMover.SetVelocity(500);
                Station[2].CurrentMover.MoveToStation(Station[3]);
				state2 :=0 ;
				END_IF
			
		END_CASE
		
		
		
		//Station 3 logic for Pink starbursts
		CASE state3 OF 
			0 :
			IF Station[3].MoverInPosition THEN 
				temporary := Station[3].CurrentMover.Payload;
				Axis1.Velocity := 7000;
				//Axis1.Deceleration := 8000;
				spin := temporary.Pink * 360;
				IF(Axis1.MoveRelative(spin, TRUE))THEN
				state3 := 1;
				END_IF
			END_IF
			1 :
				IF NOT(Axis1.Busy) THEN
				Station[3].CurrentMover.SetVelocity(500);
                Station[3].CurrentMover.MoveToStation(Station[4]);
				state3 :=0 ;
				END_IF
			
		END_CASE
		
		
		
		//Station 4 logic for pickup station
		IF Station[4].MoverInPosition THEN
            
			update := TRUE;
			temp := Station[4].CurrentMover.Payload;
			order_num_signal := temp.Order_Num;
			
		
			// Once picked up, move back to starting station
            IF bpicked_up THEN
				order_num_signal := 0;
				update := FALSE;
				// Ping signal to Orders.queue[Orders.first_order] for that order_num
                Station[4].CurrentMover.SetVelocity(1000);
                Station[4].CurrentMover.MoveToStation(Station[0]);
            END_IF
       
        END_IF
		
		
	
		// Example call to XTS Utility library. See Diagnostics section of docs for more info
		(*
		myMoverMileage	:= fbXtsEnvironment.XpuTcIo(1).MoverTcIo(2).GetDistanceDriven();
		*)
		
		// =============

        IF MainCommands.Stop THEN
            MainCommands.Start 	:= FALSE;
            MainState         	:= MS_ONESHOT_STOP;
        ELSIF MainCommands.Disable THEN
            MainCommands.Enable := FALSE;
            MainState           := MS_ONESHOT_STOP;
        END_IF
		
	MS_ONESHOT_STOP:	// --------------------------------------------------- SINGLE-CYCLE ISSUE HALT COMMANDS
		(*Issue a halt command, then change states right away to wait for Movers to carry out the instruction*)
	
		FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
			Mover[i].Halt();
		END_FOR
	
		MainState					:= MS_STOPPING;
	
    MS_STOPPING: // ---------------------------------------------------------- STOPPING MOVERS
		(*Movers are coming to a stop here in this state*)

		// Stop all movers
		allMoversHalted				:= TRUE;
		FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
			Mover[i].AxisReference.ReadStatus();
			IF Mover[i].AxisReference.Status.Moving THEN
				allMoversHalted		:= FALSE;
			END_IF
		END_FOR
		
		MainCommands.Start			:= FALSE;
 
		IF allMoversHalted THEN
           	MainState 				:= MS_STOPPED;
		END_IF
        

    MS_STOPPED: // ------------------------------------------------------------ Stop Command has been sent, hold here
		(*Movers are now stopped, and further Main Commands can be issued to the system*)

        IF MainCommands.Disable THEN
            MainCommands.Enable 	:= FALSE;
			MainCommands.Start		:= FALSE;
            MainState           	:= MS_ONESHOT_DISABLE;
        ELSIF MainCommands.Start THEN
            MainCommands.Stop 		:= FALSE;
            MainState         		:= MS_ENABLING_MOVERS;
        END_IF

	    // Reinit nextStation
        nextStation := 4;

        // Unregister everything from all stations
        FOR i := 0 TO GVL.NUM_STATIONS - 1 DO
            Station[i].UnregisterAll();
        END_FOR

        // Unregister everything from all Pos Trigs
        FOR i := 0 TO SIZEOF(PositionTrigger) / SIZEOF(PositionTrigger[0]) - 1 DO
            PositionTrigger[i].UnregisterAll();
        END_FOR

        // Unregister everything from all speed trigs
        FOR i := 0 TO SIZEOF(SpeedTrigger) / SIZEOF(SpeedTrigger[0]) - 1 DO
            SpeedTrigger[i].UnregisterAll();
        END_FOR

        // Unregister everything from all zones
        FOR i := 0 TO SIZEOF(Zone) / SIZEOF(Zone[0]) - 1 DO
            Zone[i].UnregisterAll();
        END_FOR
	
	MS_ONESHOT_DISABLE:	// ------------------------------------------------------- SINGLE CYCLE ISSUE DISABLE COMMANDS
		(*Mover disable commands are issued here, followed by a state tranisition to await completion of the Disabling*)
		FOR i := 0 TO GVL.NUM_MOVERS DO
			Mover[i].Disable();
		END_FOR

		MainState					:=	MS_DISABLING;
	
    MS_DISABLING: // --------------------------------------------------- DISABLING MOVERS
		(*Movers are Disabling. During this step, we also Unregister movers from relevant Objectives
		to ensure proper startup behavior*)
		
        // Reinit nextStation
        nextStation := 4;

        // Unregister everything from all stations
        FOR i := 0 TO GVL.NUM_STATIONS - 1 DO
            Station[i].UnregisterAll();
        END_FOR

        // Unregister everything from all Position triggers
        FOR i := 0 TO SIZEOF(PositionTrigger) / SIZEOF(PositionTrigger[0]) - 1 DO
            PositionTrigger[i].UnregisterAll();
        END_FOR

        // Unregister everything from all speed triggers
        FOR i := 0 TO SIZEOF(SpeedTrigger) / SIZEOF(SpeedTrigger[0]) - 1 DO
            SpeedTrigger[i].UnregisterAll();
        END_FOR

        // Unregister everything from all zones
        FOR i := 0 TO SIZEOF(Zone) / SIZEOF(Zone[0]) - 1 DO
            Zone[i].UnregisterAll();
        END_FOR
		
		allMoversDisabled				:= TRUE;
		
		FOR i := 0 TO gvl.NUM_MOVERS-1 DO
			IF NOT Mover[i].AxisReference.Status.Disabled THEN 
				allMoversDisabled		:= FALSE;
			END_IF
		END_FOR
 
        IF allMoversDisabled THEN
            MainState					:= MS_DISABLED;
        END_IF

    MS_ERROR: // --------------------------------------------------- ERRORSTATE
		(*A reset command can be included here to clear Mover errors, etc. and return
		to a controlled state*)

    MS_DEBUG: // ------------------------------------------------------- DEV USE ONLY
		(*This state is intentionally left blank, 
		for optional use by a developer during programming*)
	

END_CASE;

// Initialize and update diagnostic features
InitializeUtilityLibrary();

// Call all mover function blocks cyclically
FOR i := 0 TO GVL.NUM_MOVERS - 1 DO
    Mover[i].Cyclic(GroupRef);
	Mover[i].AxisReference.ReadStatus();
END_FOR;

// Call all station function blocks cyclically
FOR i := 0 TO GVL.NUM_STATIONS - 1 DO
    Station[i].Cyclic();
END_FOR

// Call trigger function blocks cyclically
PositionTrigger[0].Cyclic();
PositionTrigger[1].Cyclic();
PositionTrigger[2].Cyclic();

SB_dispensers[1]();
SB_dispensers[2]();
SB_dispensers[3]();

Axis1.CyclicLogic();
Axis2.CyclicLogic();
Axis3.CyclicLogic();
]]></ST>
    </Implementation>
    <Action Name="InitializeUtilityLibrary" Id="{4ac3b602-bbee-0af7-24db-b9d89bbd3ae5}">
      <Implementation>
        <ST><![CDATA[


CASE nEnvironmentState OF
	0:	// ----------------------------------------- Enable Init Items
	
		// Enable init Info Server if needed
		stXtsEnvironmentConfiguration.bEnableInitInfoServer		:= TRUE;
		
		// Enable init CA Group if needed
		stXtsEnvironmentConfiguration.bEnableInitCaGroup		:= TRUE;
		
		// Set configuration of XtsUtility init
		fbXtsEnvironment.P_XtsEnvironmentConfiguration			:= stXtsEnvironmentConfiguration;
		
		// Next step
		nEnvironmentState	:= 1;
		
	1:	// ------------------------------------------ Init Environment
		
		// Start init
		IF fbXtsEnvironment.Init(TRUE) THEN
			// stop init
			fbXtsEnvironment.Init(FALSE);
			
			// next step
			nEnvironmentState	:= 2;
		END_IF
		
	2:	// ------------------------------------------ Check for success
	
		// Check IsInitialized property
		IF fbXtsEnvironment.P_IsInitialized THEN
			// next step
			nEnvironmentState	:= 3;
		END_IF
		
	3:	// ------------------------------------------- Init Visu
	
		fbXtsEnvironmentVisu( ipTcIoXtsEnvironment := fbXtsEnvironment );
		
		// next step
		nEnvironmentState	:= 4;
		
	4:	// ------------------------------------------- Init done

		fbXtsEnvironmentVisu.Cycle();
		
END_CASE

]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="MAIN">
      <LineId Id="660" Count="8" />
      <LineId Id="1691" Count="0" />
      <LineId Id="670" Count="80" />
      <LineId Id="2147" Count="0" />
      <LineId Id="2144" Count="0" />
      <LineId Id="2146" Count="0" />
      <LineId Id="2145" Count="0" />
      <LineId Id="751" Count="17" />
      <LineId Id="770" Count="0" />
      <LineId Id="772" Count="0" />
      <LineId Id="774" Count="0" />
      <LineId Id="776" Count="0" />
      <LineId Id="778" Count="0" />
      <LineId Id="783" Count="0" />
      <LineId Id="788" Count="1" />
      <LineId Id="801" Count="0" />
      <LineId Id="803" Count="51" />
      <LineId Id="863" Count="2" />
      <LineId Id="870" Count="14" />
      <LineId Id="1303" Count="0" />
      <LineId Id="1308" Count="0" />
      <LineId Id="1766" Count="0" />
      <LineId Id="1770" Count="3" />
      <LineId Id="1767" Count="0" />
      <LineId Id="1852" Count="1" />
      <LineId Id="1774" Count="0" />
      <LineId Id="1854" Count="0" />
      <LineId Id="1776" Count="0" />
      <LineId Id="1778" Count="0" />
      <LineId Id="1940" Count="0" />
      <LineId Id="2066" Count="0" />
      <LineId Id="1768" Count="0" />
      <LineId Id="1760" Count="0" />
      <LineId Id="1755" Count="0" />
      <LineId Id="1309" Count="0" />
      <LineId Id="1306" Count="0" />
      <LineId Id="885" Count="1" />
      <LineId Id="1531" Count="0" />
      <LineId Id="1548" Count="0" />
      <LineId Id="1533" Count="0" />
      <LineId Id="1856" Count="0" />
      <LineId Id="2385" Count="0" />
      <LineId Id="1855" Count="0" />
      <LineId Id="1777" Count="0" />
      <LineId Id="1553" Count="0" />
      <LineId Id="1545" Count="1" />
      <LineId Id="1550" Count="0" />
      <LineId Id="1536" Count="4" />
      <LineId Id="1542" Count="0" />
      <LineId Id="1622" Count="0" />
      <LineId Id="1552" Count="0" />
      <LineId Id="1543" Count="1" />
      <LineId Id="1627" Count="0" />
      <LineId Id="1534" Count="0" />
      <LineId Id="1521" Count="0" />
      <LineId Id="894" Count="0" />
      <LineId Id="2167" Count="0" />
      <LineId Id="895" Count="1" />
      <LineId Id="2148" Count="1" />
      <LineId Id="2152" Count="0" />
      <LineId Id="2156" Count="0" />
      <LineId Id="2178" Count="0" />
      <LineId Id="2259" Count="0" />
      <LineId Id="2153" Count="0" />
      <LineId Id="2158" Count="0" />
      <LineId Id="2160" Count="0" />
      <LineId Id="2174" Count="0" />
      <LineId Id="2154" Count="0" />
      <LineId Id="2161" Count="0" />
      <LineId Id="2176" Count="0" />
      <LineId Id="2164" Count="0" />
      <LineId Id="2166" Count="0" />
      <LineId Id="2175" Count="0" />
      <LineId Id="2177" Count="0" />
      <LineId Id="2162" Count="0" />
      <LineId Id="2150" Count="0" />
      <LineId Id="897" Count="0" />
      <LineId Id="1217" Count="0" />
      <LineId Id="1857" Count="0" />
      <LineId Id="1366" Count="0" />
      <LineId Id="1352" Count="0" />
      <LineId Id="1443" Count="0" />
      <LineId Id="1433" Count="0" />
      <LineId Id="1558" Count="0" />
      <LineId Id="900" Count="1" />
      <LineId Id="908" Count="0" />
      <LineId Id="1441" Count="0" />
      <LineId Id="909" Count="0" />
      <LineId Id="1158" Count="0" />
      <LineId Id="1179" Count="0" />
      <LineId Id="2264" Count="17" />
      <LineId Id="1160" Count="0" />
      <LineId Id="1169" Count="0" />
      <LineId Id="1444" Count="0" />
      <LineId Id="1359" Count="0" />
      <LineId Id="1180" Count="0" />
      <LineId Id="2282" Count="17" />
      <LineId Id="1170" Count="0" />
      <LineId Id="1445" Count="1" />
      <LineId Id="1191" Count="1" />
      <LineId Id="1204" Count="1" />
      <LineId Id="2383" Count="0" />
      <LineId Id="1867" Count="0" />
      <LineId Id="1865" Count="0" />
      <LineId Id="1869" Count="0" />
      <LineId Id="1864" Count="0" />
      <LineId Id="1863" Count="0" />
      <LineId Id="1206" Count="0" />
      <LineId Id="2386" Count="0" />
      <LineId Id="1554" Count="0" />
      <LineId Id="1556" Count="0" />
      <LineId Id="1207" Count="3" />
      <LineId Id="1194" Count="0" />
      <LineId Id="1312" Count="0" />
      <LineId Id="910" Count="0" />
      <LineId Id="942" Count="153" />
      <LineId Id="1290" Count="0" />
      <LineId Id="1436" Count="0" />
      <LineId Id="1435" Count="0" />
      <LineId Id="1447" Count="1" />
      <LineId Id="1291" Count="0" />
      <LineId Id="1299" Count="0" />
      <LineId Id="2142" Count="1" />
      <LineId Id="1096" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.InitializeUtilityLibrary">
      <LineId Id="2" Count="49" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>